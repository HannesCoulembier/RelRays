#version 430
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38

struct ColorSpectraDescription {
    
    int     InfraredSpectrumIndex;
    int     InfraredSpectrumSize;
    float   InfraredSpectrumMinWaveLength;
    float   InfraredSpectrumMaxWaveLength;

    int     RedSpectrumIndex;
    int     RedSpectrumSize;
    float   RedSpectrumMinWaveLength;
    float   RedSpectrumMaxWaveLength;

    int     GreenSpectrumIndex;
    int     GreenSpectrumSize;
    float   GreenSpectrumMinWaveLength;
    float   GreenSpectrumMaxWaveLength;

    int     BlueSpectrumIndex;
    int     BlueSpectrumSize;
    float   BlueSpectrumMinWaveLength;
    float   BlueSpectrumMaxWaveLength;

    vec4    RelativeWeights;
};
struct ObjectDescription {
    int OldestFragmentIndex; // Lowest index (the newest object fragments have the highest indices)
    int NumberOfFragments;

    int FirstIndexIndex;
    int IndexCount;
};
struct ObjectFragment {
    vec4 StartPos;
    vec3 StartVel;
    int MaterialIndex;
};
struct Material {
	vec4 Albedo;
	// float Roughness;
	float Absorption;
	vec4 EmissionColor;
	float EmissionStrength;
    ColorSpectraDescription AbsorptionSpectraDescription;
    ColorSpectraDescription EmissionSpectraDescription;
};
struct Vertex {
    vec3 Position;
};

layout(         binding = 0, rgba8) uniform image2D colorBuffer;
layout(         binding = 1)        uniform         RenderSettingsBlock     {
    int RayBounces;
    int Samples;
} RenderSettings;
layout(         binding = 2)        uniform         CameraBlock             {
    vec3 Pos;
    vec3 Vel;
    vec3 Acc;
    mat4 InvView;
    mat4 InvProj;
    ColorSpectraDescription ColorSpectraDescription;
} Camera;
layout(         binding = 3)        uniform         SceneBlock              {
    vec4 AmbientLight;
    float OriginTime;
    float c;
} Scene;
layout(std140,  binding = 4 )       readonly buffer ObjectDescriptionBlock  { ObjectDescription objectDescriptions[]; };
layout(std140,  binding = 5 )       readonly buffer ObjectFragmentBlock     { ObjectFragment objectFragments[]; };
layout(std140,  binding = 6 )       readonly buffer MaterialBlock           { Material materials[]; };
layout(         binding = 7 )       readonly buffer SpectrumBlock           { float spectra[]; };
layout(         binding = 8 )       readonly buffer VertexBufferBlock       { Vertex vertices[]; };
layout(         binding = 9 )       readonly buffer IndexBufferBlock        { int indices[]; };

vec4 pathAccLight = vec4(0.0, 0.0, 0.0, 0.0);
vec4 pathAccAbsorbed = vec4(0.0, 0.0, 0.0, 0.0);

struct Ray {
    vec4 Origin;
    vec3 Direction;
};

struct HitPayload {
    float HitDistance;
    vec3 HitPos;
    vec3 HitNormal;
    int ObjectDescriptionIndex;
    int ObjectFragmentIndex;
};

struct SmallHitPayload {
    float HitDistance;
};

HitPayload TraceRay(Ray ray);
SmallHitPayload CalculateHitDistance(Ray ray, vec3 pos1, vec3 pos2, vec3 pos3, vec4 objStartPos, vec3 objStartVel);
HitPayload ClosestHit(Ray ray, float hitDistance, int objectDescriptionIndex, int objectFragmentIndex, int firstTriangleIndexIndex);
HitPayload Miss(Ray ray);

// Special relativity helper functions
mat4 BoostOriginToObjectMat(vec3 vel) { // Assumes (0,0) coordinate is the same in both reference frames

    float c = Scene.c;
    float v = length(vel);
    if (v <= 0.0)
        return mat4(
                        1.0, 0.0, 0.0, 0.0,
                        0.0, 1.0, 0.0, 0.0,
                        0.0, 0.0, 1.0, 0.0,
                        0.0, 0.0, 0.0, 1.0
                    );
    vec3 Beta = vel / c;
    float beta = v / c;
    float gamma = 1.0 / sqrt(1.0 - beta * beta);
    return mat4(
                    1.0 + (gamma - 1.0) * Beta.x * Beta.x / (beta*beta),    (gamma - 1.0) * Beta.y * Beta.x / (beta*beta),          (gamma - 1.0) * Beta.z * Beta.x / (beta*beta),          -gamma * Beta.x,
                    (gamma - 1.0) * Beta.x * Beta.y / (beta*beta),          1.0 + (gamma - 1.0) * Beta.y * Beta.y / (beta*beta),    (gamma - 1.0) * Beta.z * Beta.y / (beta*beta),          -gamma * Beta.y,
                    (gamma - 1.0) * Beta.x * Beta.z / (beta*beta),          (gamma - 1.0) * Beta.y * Beta.z / (beta*beta),          1.0 + (gamma - 1.0) * Beta.z * Beta.z / (beta*beta),    -gamma * Beta.z,
                    -gamma * Beta.x,                                        -gamma * Beta.y,                                        -gamma * Beta.z,                                        gamma
                );
}

mat4 BoostObjectToOriginMat(vec3 vel) { // Assumes (0,0) coordinate is the same in both reference frames
    
    return inverse(BoostOriginToObjectMat(vel));
}

void TracePath() {
    
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    ivec2 screenSize = imageSize(colorBuffer);
	vec2 uv = vec2(float(screenPos.x) / float(screenSize.x), float(screenPos.y) / float(screenSize.y)); // uv with 0,0 in bottom left corner
	vec2 coord = uv * 2.0f - 1.0f; // -1 -> 1

    Ray ray;
    ray.Origin = vec4(Camera.Pos, Scene.OriginTime);
    vec4 target = Camera.InvProj * vec4(coord.x, coord.y, 1, 1);
    ray.Direction = vec3(Camera.InvView * vec4(normalize(vec3(target) / target.w), 0)); // Camera space
    
    float c = Scene.c;

    // Converting the ray direction in camera space to the ray direction in origin space
    {
        vec3 V = Camera.Vel;
        vec3 D = ray.Direction;
        float v = length(V);
        float beta = v / c;
        float gamma = 1.0 / sqrt(1.0 - beta*beta);

        if (v > 0.0) {
            vec3 newDirection = (gamma * (dot(V,D) / v + beta) * V / v + D - V * dot(V,D) / (v * v)) / (gamma * (1 + beta * dot(V,D) / v));
            ray.Direction = newDirection;
        }
    }
    // -------------------------------------------------------------
    
	for (int i = 0; i < RenderSettings.RayBounces; i++) {

		HitPayload payload = TraceRay(ray);
		if (payload.HitDistance < 0.0) { // HitDistance < 0.0 means it missed
            
            vec4 skyLight = Scene.AmbientLight;
            pathAccLight += skyLight * pathAccAbsorbed;
			break;
        }

        ObjectDescription objectDescription = objectDescriptions[payload.ObjectDescriptionIndex];
        ObjectFragment objectFragment = objectFragments[payload.ObjectFragmentIndex];
        Material mat = materials[objectFragment.MaterialIndex];
        
        pathAccLight += mat.EmissionColor * mat.EmissionStrength * pathAccAbsorbed;
        pathAccAbsorbed *= mat.Albedo * (1.0 - mat.Absorption);

		ray.Origin = vec4(payload.HitPos + payload.HitNormal * 0.0001f, ray.Origin.w - payload.HitDistance / c);

        // To reflect the ray, we need to first transform the ray direction into object space, reflect it and then transform it back.
        {
        vec3 V = objectFragment.StartVel;
        vec3 D = ray.Direction;
        float v = length(V);
        float beta = v / c;
        float gamma = 1.0 / sqrt(1.0 - beta*beta);

        if (v > 0.0) {
            vec3 newDirection = (gamma * (dot(V,D) / v - beta) * V / v + D - V * dot(V,D) / (v * v)) / (gamma * (1 - beta * dot(V,D) / v));
            D = newDirection;
        }

        D = normalize(reflect(D, payload.HitNormal));

        if (v > 0.0) {
            vec3 newDirection = (gamma * (dot(V,D) / v + beta) * V / v + D - V * dot(V,D) / (v * v)) / (gamma * (1 + beta * dot(V,D) / v));
            D = newDirection;
        }
        ray.Direction = D;
        
        }
	}
}

void main() {

    ivec2 screenPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    ivec2 screenSize = imageSize(colorBuffer);

    pathAccLight = vec4(0.0);

    for (int i = 0; i < RenderSettings.Samples; i++) {

        pathAccAbsorbed = vec4(1.0);
        TracePath();
    }

    float ir    = pathAccLight.a;
    float r     = pathAccLight.r;
    float g     = pathAccLight.g;
    float b     = pathAccLight.b;
    vec3 finalColor = vec3(ir + r,g,b) / float(RenderSettings.Samples);
    imageStore(colorBuffer, screenPos, vec4(finalColor, 1.0));
}

HitPayload TraceRay(Ray ray) {

	int closestObjectDescription = -1;
    int closestObjectFragment = -1;
    int closestTriangleIndexIndex = -1;

	float hitDistance = FLT_MAX;

    float c = Scene.c;

	for (int i = 0; i < objectDescriptions.length(); i++) {
        
        ObjectDescription objectDescription = objectDescriptions[i];

        for (int j = 0; j < objectDescription.NumberOfFragments; j++) {

            ObjectFragment objectFragment = objectFragments[objectDescription.OldestFragmentIndex + j];

            for (int k = 0; k < (objectDescription.IndexCount) / 3; k++) { // Count up every 3 indices (per triangle)

                Vertex v1 = vertices[indices[objectDescription.FirstIndexIndex + k * 3 + 0]];
                Vertex v2 = vertices[indices[objectDescription.FirstIndexIndex + k * 3 + 1]];
                Vertex v3 = vertices[indices[objectDescription.FirstIndexIndex + k * 3 + 2]];

                vec3 p1 = v1.Position;
                vec3 p2 = v2.Position;
                vec3 p3 = v3.Position;

                SmallHitPayload smallPayload = CalculateHitDistance(ray, p1, p2, p3, objectFragment.StartPos, objectFragment.StartVel);
                float ct = smallPayload.HitDistance;

                float hitTime = c*ray.Origin.w - ct;

                // If the objectFragment wasn't active at the time of the hit, skip the hit (not the fragment)
                bool skipHit  = false;
                skipHit = skipHit || (hitTime < c*objectFragment.StartPos.w);
                if (j < objectDescription.NumberOfFragments - 1) { // If this fragment is not the newest fragment, check the time of the next fragment
                    
                    ObjectFragment nextFragment = objectFragments[objectDescription.OldestFragmentIndex + j + 1];
                    skipHit = skipHit || c*nextFragment.StartPos.w <= hitTime;
                }
                if (skipHit)
                    continue; // Skips the hit

                if (ct > 0.0 && ct < hitDistance) {
                    hitDistance = ct;
                    closestObjectDescription = i;
                    closestObjectFragment = objectDescription.OldestFragmentIndex + j;
                    closestTriangleIndexIndex = objectDescription.FirstIndexIndex + k * 3;
                }
            }
        }
    }
    
	if (closestObjectDescription < 0) {
		return Miss(ray);
    }

	return ClosestHit(ray, hitDistance, closestObjectDescription, closestObjectFragment, closestTriangleIndexIndex);
}

bool PointInTriangle(vec3 p, vec3 p0, vec3 p1, vec3 p2) {

    mat3 Ainv = mat3((p1-p0), (p2-p0), cross((p1-p0), (p2-p0)));
    mat3 A = inverse(Ainv);
    vec3 coords = A * (p-p0);
    if (coords.x < 0.0 || coords.y < 0.0 || coords.x + coords.y > 1.0)
        return false;
    return true;
}

SmallHitPayload CalculateHitDistance(Ray ray, vec3 pos1, vec3 pos2, vec3 pos3, vec4 objStartPos, vec3 objStartVel) {
    SmallHitPayload result;
    vec3 normal = normalize(cross(pos2 - pos1, pos3 - pos1));

    float c = Scene.c;
    vec3 V = objStartVel;
    float v = length(V);
    float beta = v / c;
    float gamma = 1.0 / sqrt(1.0 - beta*beta);

    // Convert ray.Direction to object space
    vec3 D = normalize((BoostOriginToObjectMat(V) * vec4(ray.Direction, 1.0)).xyz);

    // if (v > 0.0){
    //     vec3 newDirection = (gamma * (dot(V, D)/v - beta) * V / v + D - dot(V, D) * V / (v*v)) / (gamma * (1.0 - beta * dot(V, D) / v));
    //     D = newDirection;
    // }

    // Convert ray.Origin to object space
    vec4 rO = BoostOriginToObjectMat(V) * vec4(ray.Origin.xyz - objStartPos.xyz, c*ray.Origin.w - c*objStartPos.w); // Object space

    if (dot(normal, D) != 0.0) {
        
        float ct = dot(normal, (pos1 - rO.xyz)) / dot(normal, D); // ct in object space

        // Check if hitPoint is in triangle
        vec4 hitPos = rO - ct * vec4(D, 1.0); // In object space
        bool isInTriangle = PointInTriangle(hitPos.xyz, pos1, pos2, pos3);
        if (isInTriangle) {
            // Convert ct to origin space
            hitPos = BoostObjectToOriginMat(V) * hitPos + vec4(objStartPos.xyz, c*objStartPos.w); // Brings the hitPos to origin space
            // if (v > 0.0)
            //     ct = gamma * (ct - beta * dot(V/v, hitPos.xyz));
            // result.HitDistance = ct;
            result.HitDistance = c*ray.Origin.w - hitPos.w;
        }
        else
            result.HitDistance = -1.0;
    }
    else
        result.HitDistance = -1.0;
    return result;
}

HitPayload Miss(Ray ray) {
    
    HitPayload payload;
    payload.HitDistance = -1.0;
    payload.HitPos = vec3(0.0);
    payload.HitNormal = ray.Direction;
    payload.ObjectDescriptionIndex = -1;
    payload.ObjectFragmentIndex = -1;
    return payload;
}

HitPayload ClosestHit(Ray ray, float hitDistance, int objectDescriptionIndex, int objectFragmentIndex, int firstTriangleIndexIndex) {
    
    ObjectDescription objectDescription = objectDescriptions[objectDescriptionIndex];
    ObjectFragment objectFragment = objectFragments[objectFragmentIndex];
    Vertex v1 = vertices[indices[firstTriangleIndexIndex + 0]];
    Vertex v2 = vertices[indices[firstTriangleIndexIndex + 1]];
    Vertex v3 = vertices[indices[firstTriangleIndexIndex + 2]];

    vec3 planeNormal = normalize(cross((v2.Position - v1.Position), (v3.Position - v1.Position)));

    HitPayload payload;

	payload.HitDistance = hitDistance;
	payload.HitPos = ray.Origin.xyz + ray.Direction * hitDistance;
	payload.HitNormal = normalize(-planeNormal * dot(ray.Direction, planeNormal)); // Multiply by dot of ray direction and normal to get the normal to face the right way, then normalize (this is because the normal is later used to slightly offset the new ray origin from the hitpoint)
    payload.ObjectDescriptionIndex = objectDescriptionIndex;
    payload.ObjectFragmentIndex = objectFragmentIndex;

    return payload;
}